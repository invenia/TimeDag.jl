var documenterSearchIndex = {"docs":
[{"location":"concepts/#Concepts","page":"Concepts","title":"Concepts","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"This document explains some key concepts and terminology.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"We begin with a mathematical framework for expressing time-series operations. This is then used to form analogies with code in TimeDag, and motivate some of the design decisions.","category":"page"},{"location":"concepts/#Time-series","page":"Concepts","title":"Time-series","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"We define a time-series x in mathcalTS subset mathcalT times mathcalX to be an ordered sequence of N time-value pairs:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"beginaligned\nx   = (t_i x_i)  i in 1 N\nt_i in mathcalT_x forall i quad mathcalT_x = t_1 infty) subset mathcalT\nx_i in mathcalX forall i\nt_i  t_i-1 forall i\nendaligned","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Here we use mathcalT to denote the type of time.[1] We only require that there is a total order on mathcalT — but thinking about it as a real number is a good analogy. We also, somewhat sloppily, identify infty with max mathcalT.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"[1]: We currently require that all times are instances of DateTime.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"This restriction may be relaxed in the future.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Colloquially, we will refer to a time-value pair as a knot.[2]","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"[2]: Diagrams in the alignment section will perhaps be reminiscent of the rope on a ship log.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"mathcalT_x is the semi-infinite interval bounded below by the time of the first knot in x.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"We define the TimeDag.value_type of x to be the set mathcalX above, and in practice this can be any Julia type.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"TimeDag primarily represents a time-series as a TimeDag.Node.  It also stores time-series data in memory in the Block type.","category":"page"},{"location":"concepts/#Functional-interpretation","page":"Concepts","title":"Functional interpretation","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"We can also consider x to be a function, x  mathcalT_x rightarrow mathcalX. This is defined x(t) = max_i x_i textrmst t_i leq t.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Informally, this means that whenever we observe a value x_i, the 'value of' the time-series is x_i until such time as we observe x_i+1.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Sometimes it is useful to define x(t_-) = oslash forall t_- in mathcalT setminus mathcalT_x. Here, oslash is a placeholder element that simply means \"no value\".","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"info: Info\nNote that time is strictly increasing, and repeated times are not permitted. This conceptual choice is necessary to consider x to be a map from time to value as above. Without this restriction, there is an ambiguity whenever a time is repeated.","category":"page"},{"location":"concepts/#Functions-of-time-series","page":"Concepts","title":"Functions of time-series","text":"","category":"section"},{"location":"concepts/#General-case","page":"Concepts","title":"General case","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"We wish to define a general notion of a function f  mathcalTS times cdots times mathcalTS rightarrow mathcalTS. Let z = f(x y ldots), where x, y and z are all time-series.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Firstly, we define an indicator-like function f_t(t ldots) in 01, which returns 1 iff we should emit a value at time t:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"t_i = t in mathcalT  f_t(t x(t)  t leq t y(t)  t leq t ldots) = 1","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Colloquially, whenever f_t returns 1 we say that z ticks, i.e. emits a knot.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Then, we require that each value z_i at time t_i can be written as the result of a function f:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"z_i = f(t_i x(t)  t leq t_i y(t)  t leq t_i ldots)","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"info: Info\nLet us unpack this notation a bit:Knots of z are only allowed to depend on non-future values of x and y.\nz can tick whenever it likes, possibly dependent on values of x and y.\nThe knot emitted can be a function of time.The first of these is an important requirement, and TimeDag aims to enforce this structurally.","category":"page"},{"location":"concepts/#Parameters","page":"Concepts","title":"Parameters","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"In the above discussion, all arguments to f are time-series. Such functions could additionally have some other non-time-series constant parameters, which we will denote thetainTheta. Strictly mathematically, note that a \"constant\" can just be viewed as a time-series with a single observation at min mathcalT; so the above description is still fully general.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"In practice (for efficient implementation) we will want function f  Theta times mathcalTS times cdots rightarrow mathcalTS. So, f(theta x y ldots) then has some constant parameter(s) theta.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"We'll continue to drop the explicit theta dependence where it isn't interesting, to simplify notation.","category":"page"},{"location":"concepts/#Explicit-state","page":"Concepts","title":"Explicit state","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"It is useful to re-write the value computation by introducing the notion of a 'state' zeta_i:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"beginaligned\nz_i zeta_i = f_v(t_i zeta_i-1 x(t_i) y(t_i) ldots)\nendaligned","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Each state zeta_i-1 needs to package as much information about the history of the inputs as necessary to compute each z_i (as well as the new state zeta_i).","category":"page"},{"location":"concepts/#Batching","page":"Concepts","title":"Batching","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Note that, even after the re-arrangement in Explicit state, f_t is still a bit awkward. One cannot directly implement it — otherwise one has to call f_t for every t in an infinite (or at least very large) set.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"First, let us introduce the notion of slicing. Define an interval delta = t_1t_2) subset mathcalT.[3] Then, the slice of x over delta, which we'll write as x = xdelta, is a new time-series with support mathcalT_x = delta cap mathcalT_x.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"[3]: One is free to choose the open/closed-ness of each bound, however the use of an closed-open interval helps in subsequent analysis.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Let delta_i represent an ordered non-overlapping set of intervals, whose union covers all of mathcalT. We then write, analogous to the definition of f_v:","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"zdelta_i zeta_sup delta_i = f_b(delta_i zeta_sup delta_i-1 xdelta_i ydelta_i ldots)","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"This function outputs knots — time-value pairs — rather than just the values, and hence performs the roles of both f_t and f_v previously.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"NB The state zeta is only subscripted by the upper bound of a given interval; i.e. by a time. This is because the state should not be path-dependent.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"info: Info\nIt is useful to emphasise this distinction:f — a time-series operation. This is TimeDag.NodeOp.\nf_b — the implementation of f. This is TimeDag.run_node!.Helpfully, often f has simple semantics & behaviour that can be reasoned about. The implementation details can be ignored in this reasoning.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"warning: Warning\nA little thought shows that f_b, and hence TimeDag.run_node!, can express illegal time-series operations that future-peek. Care must be taken when implementing this low-level interface!Where possible, when custom operations are required, use the higher-level abstractions referred to below.","category":"page"},{"location":"concepts/#Classes-of-function","page":"Concepts","title":"Classes of function","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"All time-series functions in TimeDag are of the form of f above. Here we identify a few categories of such functions which cover many of the cases of interest.","category":"page"},{"location":"concepts/#No-inputs","page":"Concepts","title":"No inputs","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"A function f  emptyset rightarrow mathcalTS can be considered a source. That is, it generates a time-series with no inputs.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"In this case, if z = f(), then the implementation f_b technically reduces to zdelta = f_b(delta). In principle no state is required, since there is no external information to remember. However, in practice retaining the state term can be useful to increase implementation efficiency.","category":"page"},{"location":"concepts/#Single-input-(map-over-values)","page":"Concepts","title":"Single input (map over values)","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Consider an unary - function operating on a time-series; z = -x. This is a \"boring\" time-series operation, in that all times of z are identical to those of x. The values are determined by z_i = -x_i forall i.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"Some unary operators from Base, like Base.:-, have methods on TimeDag.Node defined within TimeDag.","category":"page"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"More generally, wrap and wrapb let you create a time-series function from such an unary function. See Creating operations for more details.","category":"page"},{"location":"concepts/#Single-input-(lag)","page":"Concepts","title":"Single input (lag)","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"A lag is a slightly more complex unary function. TODO","category":"page"},{"location":"concepts/#Alignment","page":"Concepts","title":"Alignment","text":"","category":"section"},{"location":"concepts/","page":"Concepts","title":"Concepts","text":"TODO Immediately, we note that mathcalT_z subset mathcalT_x cup mathcalT_y. That is, z(t) can only be defined ","category":"page"},{"location":"concepts/#Why-a-computational-graph?","page":"Concepts","title":"Why a computational graph?","text":"","category":"section"},{"location":"reference/sources/#Sources","page":"Sources","title":"Sources","text":"","category":"section"},{"location":"reference/sources/","page":"Sources","title":"Sources","text":"The following functions construct nodes with no parents.","category":"page"},{"location":"reference/sources/","page":"Sources","title":"Sources","text":"block_node\nempty_node\nTimeDag.tea_file","category":"page"},{"location":"reference/sources/#TimeDag.block_node","page":"Sources","title":"TimeDag.block_node","text":"block_node(block::Block)\n\nConstruct a node whose values are read directly from the given block.\n\n\n\n\n\n","category":"function"},{"location":"reference/sources/#TimeDag.empty_node","page":"Sources","title":"TimeDag.empty_node","text":"empty_node(T)\n\nConstruct a node with value type T which, if evaluated, will never tick.\n\n\n\n\n\n","category":"function"},{"location":"reference/sources/#TimeDag.tea_file","page":"Sources","title":"TimeDag.tea_file","text":"tea_file(path::AbstractString, value_field_name)\n\nGet a node that will read data from the tea file at path.\n\nSuch a tea file must observe the following properties, which will be verified at runtime:\n\nHave a primary time field which is compatible with a Julia DateTime.\nHave exactly one column with name value_field_name.\nHave strictly increasing times.\n\nUpon node creation, the metadata section of the file will be parsed to infer the value type of the resulting node. However, the bulk of the data will only be read at evaluation time.\n\nSee also\n\nThe tea file spec\nTeaFiles.jl\n\n\n\n\n\n","category":"function"},{"location":"reference/creating_ops/#Creating-operations","page":"Creating operations","title":"Creating operations","text":"","category":"section"},{"location":"reference/creating_ops/","page":"Creating operations","title":"Creating operations","text":"Sometimes the operations contained in TimeDag will not be sufficient. This document explains how new operations can be created.","category":"page"},{"location":"reference/creating_ops/","page":"Creating operations","title":"Creating operations","text":"wrap\nwrapb","category":"page"},{"location":"reference/creating_ops/#TimeDag.wrap","page":"Creating operations","title":"TimeDag.wrap","text":"wrap(f::Function)\n\nReturn a callable object that acts on nodes, and returns a node.\n\nIt is assumed that f is stateless and time-independent. We also assume that we will always emit a knot when the alignment semantics say we should — thus f must always return a valid output value.\n\nIf the object is called with more than one node, alignment will be performed. In this case, the final argument can be an Alignment instance, otherwise DEFAULT_ALIGNMENT will be used.\n\nInternally this will call TimeDag.apply(f, args...); see there for further details.\n\n\n\n\n\n","category":"function"},{"location":"reference/creating_ops/#TimeDag.wrapb","page":"Creating operations","title":"TimeDag.wrapb","text":"wrapb(f::Function)\n\nLike wrap(f), however f will be broadcasted over all input values.\n\n\n\n\n\n","category":"function"},{"location":"reference/fundamentals/#Fundamentals","page":"Fundamentals","title":"Fundamentals","text":"","category":"section"},{"location":"reference/fundamentals/#Data","page":"Fundamentals","title":"Data","text":"","category":"section"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"Time-series data is stored internally in a Block. More information on what we mean by a time-series is explained in Time-series.","category":"page"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"Block","category":"page"},{"location":"reference/fundamentals/#TimeDag.Block","page":"Fundamentals","title":"TimeDag.Block","text":"Block{T}()\nBlock(times::AbstractVector{DateTime}, values::AbstractVector{T})\nBlock(unchecked, times, values)\n\nRepresent some data in timeseries.\n\nConceptually this is a list of (time, value) pairs, or \"knots\". Times must be strictly increasing — i.e. no repeated timestamps are allowed.\n\nThe constructor Block(times, values) will verify that the input data satisfies this constraint, however Block(unchecked, times, values) will skip the checks. This is primarily intended for internal use, where the caller assumes responsibility for the validity of times & values.\n\n\n\n\n\n","category":"type"},{"location":"reference/fundamentals/#Computational-graph","page":"Fundamentals","title":"Computational graph","text":"","category":"section"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"The computational graph is formed of TimeDag.Node objects. A node is an abstract representation of a time-series, i.e. a sequence of (time, value) pairs. A node knows the type of its values, which can be queries with TimeDag.value_type.","category":"page"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"Note that nodes should never be constructed directly by the user. Typically one will call a function like block_node or lag, which will construct a node.","category":"page"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"TimeDag.jl includes functions to construct many useful nodes, but often you will need to create a custom node. See Creating nodes for instructions on how to do this.","category":"page"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"info: Info\nAll nodes should eventually be constructed with TimeDag.obtain_node. This uses the global Identity map to ensure that we do not duplicate nodes.","category":"page"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"TimeDag.Node\nTimeDag.value_type","category":"page"},{"location":"reference/fundamentals/#TimeDag.Node","page":"Fundamentals","title":"TimeDag.Node","text":"Node(parents, op)\n\nA node in the computational graph that combines zero or more parents with op to produce a timeseries.\n\nwarning: Warning\nNote that a Node is only declared mutable so that we can attach finalizers to instances. This is required for the WeakIdentityMap to work. Nodes should NEVER actually be mutated!\n\nDue to subgraph elimination, nodes that are equivalent should always be identical objects. We therefore leave hash & == defined in terms of the objectid.\n\n\n\n\n\n","category":"type"},{"location":"reference/fundamentals/#TimeDag.value_type","page":"Fundamentals","title":"TimeDag.value_type","text":"value_type(node::Node{T}) -> T\n\nThe type of each value emitted for this node.\n\n\n\n\n\n","category":"function"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"Every node contains parents, and a TimeDag.NodeOp.","category":"page"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"TimeDag.NodeOp\nTimeDag.obtain_node","category":"page"},{"location":"reference/fundamentals/#TimeDag.NodeOp","page":"Fundamentals","title":"TimeDag.NodeOp","text":"abstract type NodeOp{T} end\n\nRepresent a time-series operation whose output will be a time-series with value type T.\n\n\n\n\n\n","category":"type"},{"location":"reference/fundamentals/#TimeDag.obtain_node","page":"Fundamentals","title":"TimeDag.obtain_node","text":"obtain_node(parents::NTuple{N,Node}, op::NodeOp) -> Node\n\nGet a node for the given op and parents. If an equivalent node already exists in the global identity map, use that one, otherwise create a new node, add to the identity map, and return it.\n\nConstant propagation\n\nIf all parents are constant nodes, and op has a well-defined operation on constant inputs, we will immediately perform the computation and return a constant node wrapping the computed value.\n\n\n\n\n\n","category":"function"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"Given a node, a rough-and-ready way to visualise the graph on the command line is with AbstractTrees.print_tree. This will not directly indicated repeated nodes, but for small graphs the output can be useful.","category":"page"},{"location":"reference/fundamentals/#Evaluation","page":"Fundamentals","title":"Evaluation","text":"","category":"section"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"In order to get a concrete time-series (as a Block) for a node, it must be evaluated with evaluate. Evaluation additionally requires a time range, and involves pulling data corresponding to this interval through the graph of ancestors of the given node(s).","category":"page"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"info: Info\nWhen evaluating a graph in a production system, it may be desirable to have more control over evaluation. If this sounds like you, please read the Advanced evaluation section!","category":"page"},{"location":"reference/fundamentals/","page":"Fundamentals","title":"Fundamentals","text":"evaluate","category":"page"},{"location":"reference/fundamentals/#TimeDag.evaluate","page":"Fundamentals","title":"TimeDag.evaluate","text":"evaluate(nodes::AbstractVector{Node}, t0, t1[; batch_interval]) -> Vector{Block}\nevaluate(node::Node, t0, t1[; batch_interval]) -> Block\n\nEvaluate the specified node(s) over the specified time range [t0, t1), and return the corresponding Block(s).\n\nIf nodes have common dependencies, work will not be repeated when performing this evaluation.\n\n\n\n\n\n","category":"function"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"The following examples demonstrate some of the basic functionality in TimeDag.jl.","category":"page"},{"location":"reference/align/#Alignment","page":"Alignment","title":"Alignment","text":"","category":"section"},{"location":"reference/align/","page":"Alignment","title":"Alignment","text":"left\nright\nalign\nlag","category":"page"},{"location":"reference/align/#TimeDag.left","page":"Alignment","title":"TimeDag.left","text":"left(x, y[, alignment::Alignment])\n\nConstruct a node that ticks according to alignment with the latest value of x.\n\nIt is \"left\", in the sense of picking the left-hand of the two arguments x and y.\n\n\n\n\n\n","category":"function"},{"location":"reference/align/#TimeDag.right","page":"Alignment","title":"TimeDag.right","text":"right(x, y[, alignment::Alignment])\n\nConstruct a node that ticks according to alignment with the latest value of y.\n\nIt is \"right\", in the sense of picking the right-hand of the two arguments x and y.\n\n\n\n\n\n","category":"function"},{"location":"reference/align/#TimeDag.align","page":"Alignment","title":"TimeDag.align","text":"align(x, y)\n\nForm a node that ticks with the values of x whenever y ticks.\n\n\n\n\n\n","category":"function"},{"location":"reference/align/#TimeDag.lag","page":"Alignment","title":"TimeDag.lag","text":"lag(x::Node, n::Integer)\n\nConstruct a node which takes values from x, but lags them by n knots.\n\nThis means that we do not introduce any new timestamps that do not appear in x, however we will not emit knots for the first n values that appear when evaluating x.\n\n\n\n\n\n","category":"function"},{"location":"reference/arithmetic/#Arithmetic","page":"Arithmetic","title":"Arithmetic","text":"","category":"section"},{"location":"reference/arithmetic/","page":"Arithmetic","title":"Arithmetic","text":"Modules = [TimeDag]\nPages = [\n    \"ops/simple.jl\",\n]","category":"page"},{"location":"reference/online_windowed/#Online-and-windowed","page":"Online & windowed","title":"Online & windowed","text":"","category":"section"},{"location":"reference/online_windowed/#","page":"Online & windowed","title":"","text":"","category":"section"},{"location":"reference/online_windowed/#History","page":"Online & windowed","title":"History","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = TimeDag","category":"page"},{"location":"#TimeDag","page":"Home","title":"TimeDag","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for TimeDag.jl!","category":"page"},{"location":"","page":"Home","title":"Home","text":"TimeDag.jl enables you to build and run time-series models efficiently.","category":"page"},{"location":"","page":"Home","title":"Home","text":"You might want to use this package if some of the following apply:","category":"page"},{"location":"","page":"Home","title":"Home","text":"You are processing data with a natural time ordering.\nYou need to handle data sources that update irregularly.\nYou are building online-updating statistical models.\nYour input data is too large to fit in memory.\nYour system has several components that share similar computation.\nYou want to create a real-time system, but also test it over a large historical dataset.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package was built with Invenia's work in electricity grids in mind. Other domains that could be suitable include sensor, system monitoring, and financial market data.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"It might be helpful to begin with the Concepts.","category":"page"},{"location":"reference/internals/#Internals","page":"Internals","title":"Internals","text":"","category":"section"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"This page documents internal, and less commonly-used API. Some of it will be useful for users for more advanced use-cases, like running graphs in production systems. Other parts shouldn't need to be regularly interacted with, but can be useful to know about.","category":"page"},{"location":"reference/internals/#Identity-map","page":"Internals","title":"Identity map","text":"","category":"section"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"One of the key features of TimeDag.jl is avoiding duplicating work.","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"This is primarily achieved by ensuring that we never construct the 'same' node twice. By 'same', here we mean two nodes that we can prove will always give the same output.","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"One easy-to-handle case is that of a node that has identical parents & op to another. To avoid this, TimeDag.jl maintains a global identity map, of type TimeDag.IdentityMap.","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"Currently the only implementation of the identity map is TimeDag.WeakIdentityMap. This contains weak references to nodes, to ensure that we know about all nodes that currently exist, but don't unnecessarily prevent nodes from being garbage collected when we no longer want them.","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"In practice, all nodes should be constructed indirectly using TimeDag.obtain_node.  This will query the global_identity_map(), and only construct a new node if an equivalent one does not already exist.","category":"page"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"TimeDag.IdentityMap\nTimeDag.obtain_node!\nTimeDag.global_identity_map\nTimeDag.WeakNode\nTimeDag.WeakIdentityMap","category":"page"},{"location":"reference/internals/#TimeDag.IdentityMap","page":"Internals","title":"TimeDag.IdentityMap","text":"IdentityMap\n\nAn abstract identity map.\n\nAny implementation of this type needs to implement obtain_node!.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#TimeDag.obtain_node!","page":"Internals","title":"TimeDag.obtain_node!","text":"obtain_node!(id_map::IdentityMap, parents::NTuple{N,Node}, op::NodeOp) -> Node\n\nIf a node with parents and op doesn't exist inside id_map, create and insert it.\n\nReturn either the new or existing node.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#TimeDag.global_identity_map","page":"Internals","title":"TimeDag.global_identity_map","text":"global_identity_map() -> IdentityMap\n\nGet the global IdentityMap instance used in TimeDag.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#TimeDag.WeakNode","page":"Internals","title":"TimeDag.WeakNode","text":"WeakNode(parents, op)\n\nRepresent a node-like object that doesn't hold strong references to its parents.\n\nThis exists purely such that hash and == do allow multiple instances of WeakNode to compare equal if they have the same parents and op.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#TimeDag.WeakIdentityMap","page":"Internals","title":"TimeDag.WeakIdentityMap","text":"WeakIdentityMap\n\nRepresent a collection of nodes which doesn't hold strong references to any nodes.\n\nThis is useful, as it allows the existence of this cache to be somewhat transparent to the user, and they only have to care about holding on to references for nodes that they care about.\n\nThis structure contains nodes, but also node weak nodes – these allow us to determine whether we ought to create a given node.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#Advanced-evaluation","page":"Internals","title":"Advanced evaluation","text":"","category":"section"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"Sometimes evaluate does not provide enough control. This section goes into more detail about how evaluation works, and in particular how this can be useful for live systems.","category":"page"},{"location":"reference/internals/#Evaluation-state","page":"Internals","title":"Evaluation state","text":"","category":"section"},{"location":"reference/internals/#Batching","page":"Internals","title":"Batching","text":"","category":"section"},{"location":"reference/internals/#Scheduling","page":"Internals","title":"Scheduling","text":"","category":"section"},{"location":"reference/internals/","page":"Internals","title":"Internals","text":"TimeDag.EvaluationState\nTimeDag.NodeEvaluationState\nTimeDag.start_at\nTimeDag.get_up_to!\nTimeDag.run_node!","category":"page"},{"location":"reference/internals/#TimeDag.EvaluationState","page":"Internals","title":"TimeDag.EvaluationState","text":"EvaluationState\n\nAll state necessary for the evaluation of some nodes.\n\nThis should be created with start_at.\n\nFields\n\nordered_node_to_children::OrderedDict{Node,Set{Node}}: a map from every node which we   need to run, to its children. The ordering of the elements is such that, if evaluated in   this order, all dependencies will be evaluated before they are required.\nnode_to_state::IdDict{Node,NodeEvaluationState}: maintain the state for every node   being evaluated.\ncurrent_time::DateTime: the time to which this state corresponds.\nevaluated_node_to_blocks::IdDict{Node,Vector{Block}}: the output blocks that we care   about.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#TimeDag.NodeEvaluationState","page":"Internals","title":"TimeDag.NodeEvaluationState","text":"abstract type NodeEvaluationState end\n\nRepresents any and all state that a node must retain between evaluating batches.\n\nInstances of subtypes of NodeEvaluationState are given to run_node!.\n\n\n\n\n\n","category":"type"},{"location":"reference/internals/#TimeDag.start_at","page":"Internals","title":"TimeDag.start_at","text":"start_at(nodes, time_start::DateTime) -> EvaluationState\n\nCreate a sufficient EvaluationState for the evaluation of nodes.\n\nInternally, this will determine the subgraph that needs evaluating, i.e. all the ancestors of nodes, and create a NodeEvaluationState for each of these.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#TimeDag.get_up_to!","page":"Internals","title":"TimeDag.get_up_to!","text":"get_up_to!(state::EvaluationState, time_end::DateTime)\n\nUpdate the evaluation state by performing the evalution for each node.\n\n\n\n\n\n","category":"function"},{"location":"reference/internals/#TimeDag.run_node!","page":"Internals","title":"TimeDag.run_node!","text":"run_node!(\n    state::NodeEvaluationState,\n    op::NodeOp{T},\n    time_start::DateTime,\n    time_end::DateTime,\n    input_blocks::Block...\n) -> Block{T}\n\nEvaluate the given node from time_start to time_end, with the initial state. Zero or more blocks will be passed as an input; these correspond to the parents of a node, and are passed in the same order as that returned by parents(node).\n\nWe return a new Block of output knots from this node.\n\nwarning: Warning\nThe implementer of run_node! must ensure that no future peeking occurs. That is, that no output knot is dependent on input knots that occur subsequently.\n\n\n\n\n\n","category":"function"}]
}
